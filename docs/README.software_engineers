DSSS is a tool to:

* Build D software.
* Install D software.
* Configure D software dependencies and libraries.
* Maintain a repository of DSSS-compatible D sources to be easily installable
  via the Internet.

This document explains the use of DSSS by software engineers wishing to use
DSSS as a project management solution.


== OVERVIEW ==

Software utilizing DSSS is configured with a file named "dsss.conf". This file
describes the components of the complete software package and how each component
should be built.

dsss.conf files are plain text files, in a format similar to Windows INI files.
They are intentionally minimalistic, and require very little maintenance to keep
working.

Because dsss.conf files are minimalistic, most software packages can be
configured for use by DSSS with very simple dsss.conf files. For example, most
software packages containing one binary can have a dsss.conf file like the
following:
[example.d]
target = example_binary

This is all you need for a simple application. DSSS will parse your imports, so
you only need to list the file with the entry function (main). In most cases,
DSSS is very easy to use. Simple instructions on basic dsss.conf files is
available at http://www.dsource.org/projects/dsss/wiki/DSSSByExample


== THE BASICS ==

dsss.conf files are divided into a number of sections. Most sections describes a
single binary or library to be built.

A section is started with the file name of the source module or package in
brackets. In general, sections which are named for modules produce binaries, and
sections which are named for packages produce libraries. Each section may have
any number of settings, which customize how that section is built.

= SETTINGS =

Settings are simple name-value pairs which customize the building of sections.
The format is simple:
<name>=<value>

For example,
target=example_binary

It is also possible to add to a setting:
<name>+=<value>

e.g.:
a=Hello
a+=World

The setting 'a' is now 'Hello World'. This is most useful with versioning,
described later.

= FLAGS =

Any section may have a 'buildflags' setting, which specifies the flags to be
used while building that section. For example,
buildflags=-O

= BINARIES =

Sections which are named for D modules (.d files) produce executable binaries
when built with DSSS. The target binary file name will be deduced from the name
of the .d file, or can be set explicitly with a 'target' line, such as:
[example.d]
target=example_binary

Windows users: Be careful not to set the target of a binary build to the name of
a directory. This will work on Windows because it gains the .exe suffix, but
will fail on other operating systems.

= LIBRARIES =

Sections which are named for D packages (directories) produce libraries when
built with DSSS. The name of the library file is derived from the name of the
package and the platform. There is no reason to remember this name, however,
because DSSS will detect library dependencies and link them in automatically.
This name can partially be overridden if desired, in the same way as binaries:
[mydpackage]
target=dlibrary

However, the platform will always affect the output library name. On POSIX
systems, the above library will be named libSdlibrary.a and libdlibrary.so. On
Windows, the above library will be named Sdlibrary.lib.

By default, all of the .d files within the directory and any subdirectory will
be included in the library. Files may be excluded with the 'exclude' setting:
[mydpackage]
exclude=mydpackage/broken.d

Entire directories may also be excluded:
[mydpackage]
exclude=mydpackage/brokenpackage

The 'exclude' setting is useful in concert with versioning, described in a later
section.

= SOURCE LIBRARIES =

Source libraries are libraries which are not compiled until they are used in a
binary. They are installed in their source form. Otherwise, they act identically
to normal libraries. A source library may be specified by setting the 'type'
setting to 'sourcelibrary':
[mydpackage]
type=sourcelibrary

= SPECIAL SECTIONS =

It is also possible to create sections which are not associated with compiling
a binary or library. These sections are given names starting with a '+', such
as:
[+generate]

The utility of these sections will be seen below, in the section on hooks.


== INSTALLATION ==

DSSS is capable of installing binaries and libraries to a predetermined
directory, usually the prefix in which it is installed. When libraries are
installed in this way, they will be usable by DSSS without being explicitly
specified.


== HOOKS ==

DSSS can run arbitrary commands while building software. There are a number of
points at which commands can be run: before and after building, before and after
installing, and before and after cleaning up. These commands are added to
'prebuild', 'postbuild', 'preinstall', 'postinstall', 'preclean' and 'postclean'
lines, respectively.

Hook commands can be anything which can be run on the shell of the host system,
such as:
prebuild = echo Hello

Any number of hook commands may be strung together between semicolons:
prebuild = echo Hello ; echo World

And may span multiple lines by ending each line with a backslash:
prebuild = echo \
    Hello ; \
    echo World

Hook commands may include references to environment variables:
prebuild = echo $PREFIX

DSSS provides several environment variables for this purpose:
PREFIX: The prefix to which the software is being installed.
BIN_PREFIX: The prefix for binaries.
LIB_PREFIX: The prefix for libraries.
INCLUDE_PREFIX: The base prefix for .di files.
DOC_PREFIX: The prefix for documentation.
ETC_PREFIX: The prefix for configuration files.
EXE_EXT: The extension for executable files. Empty on POSIX, ".exe" on Windows.


There are also a number of special, builtin commands available.

= install =

The 'install' command installs a file to the specified directory. If the
directory does not exist, it is created. For example:
postinstall = install docs/README $DOC_PREFIX

Files installed in this way are recorded, so that they may be uninstalled
easily.

= cd =

The 'cd' command changes the current directory. It works exactly as on POSIX
and Windows shells:
prebuild = cd c_source ; make

= .d files =

Any .d file may be used as a command. It will be compiled and run on-the-fly:
prebuild = generateBindings.d

= set =

The 'set' command sets a setting in the dsss.conf file on-the-fly. The
parameters are:
set <section>:<setting> <value>

It is also possible to omit the section from the command to set in the current
section:
set <setting> <value>

The special section '*' may be used to set a setting in all sections:
set *:<setting> <value>

For example,
set example.d:postbuild echo Hello

'set' is most useful in concert with the 'eval' command (described below), but
can also be used alone.

= add =

The 'add' command is identical to the 'set' command, except that it appends to
the current value instead of replacing it.

For example,
add example.d:postbuild World

= eval =

The 'eval' command runs a specified command, captures its output, and then runs
its output as a command. This allows for very general processes to be
encapsulated into binaries, rather than the dsss.conf file itself.

For example, imagine the scenario that some system specifics need to be detected
and utilized in the building of a section. There can be a program, analyze.d,
which does the analysis and outputs commands such as
add *:postbuild echo Hello

This program could be run and used with the hook command:
prebuild=eval analyze.d


== VERSIONING ==

dsss.conf files support version statements with a similar syntax to D's own
version statements:

version (Windows) {
    postbuild=setupWindows.d
} else version (Posix) {
    postbuild=setupPosix.d
}

Unlike D, dsss.conf files support negative versions:

version (!Windows) {
    postbuild=giveUserCandy.d
}

dsss.conf's version statements can be used at any point in the dsss.conf file.
They can even conditionally include different sections:
version (Windows) {
    [winlib]
} else version (Posix) {
    [posixlib]
}
type = library


== GLOBAL SETTINGS ==

There are several settings that DSSS supports which are global. That is, they
are specified for the software package as a whole, rather than any section.
These are included at the top of the dsss.conf file. Common settings are 'name'
(the name of the software package) and 'version'.

It is also possible to specify global settings later in the dsss.conf file by
adding an empty section header:
[]
name=exampleSoft


== DEFAULT SETTINGS ==

It is possible to create default settings with a special "*" section. This is
most useful for settings such as 'buildflags':

[*]
buildflags=-O


To-be-written:
== SUBDIRECTORIES ==
== INTERNAL OPERATION ==


-put this somewhere-
When a library is installed via DSSS, the .d files are translated into .di (D
import) files, which are then installed to /include/d with the appropriate
names. These D import files contain references to the library itself, which
allows DSSS to include it when necessary without the user specifying it.



OLD CONTENT:

DSSS is a tool to:

* Build D software.
* Install D software.
* Configure D software dependencies and libraries.
* Maintain a repository of DSSS-compatible D sources to be easily installable
  via the Internet.

To the average software engineer, the most important part is dsss.conf, the
file added to your source code to configure how DSSS will compile it.

dsss.conf is a plain-text file, with a similar syntax to Windows INI files. It
can have any number of sections, each of which is headed with a name in
brackets, like so:
[foo/bar.d]


Most sections are named by a source file or directory. In general, sections
named for source files will generate binaries, and sections named for
directories will generate libraries. However, you can manually specify a
binary, library or sourcelibrary (like a library, but not compiled until it's
used in a binary) with the type setting:
[wholedirbinary]
type=binary

[onefilelibrary.d]
type=library

[onefilesrclib.d]
type=sourcelibrary


In each section, there can be any number of settings. Each setting is a
keyword, possibly followed by = or += and a value. For example, the "target"
setting sets the name of the output binary or library in a given section:
[main.d]
target=dzip

(In general, the target setting will be automatically set to something
sensible)


Sections creating libraries from directories will normally include all the .d
files in that directory or any subdirectory of it. You may also specify
subdirectories explicitly in dsss.conf, which will cause some .d files to be
reassigned. For example, if you have these files:
dzip/algorithm.d, foo/compression/zip.d
and a section:
[dzip]
then the produced library will include algorithm.d and zip.d.
If you have two sections:
[dzip]
[dzip/compression]
then two libraries will be produced: The library from 'dzip' will contain
algorithm.d, and the library from [dzip/compression] will contain zip.d.


Furthermore, content in dsss.conf can be set up as version-specific, with a
version keyword similar to the version keyword in D. For example, to make sure
that a certain binary is only produced on Windows:
version (Windows) {
 [dzip/windows.d]
 target=dzip_for_windows
}

The version keyword in dsss.conf also supports negation:
version (!Windows) {
 [dzip/nonwindows.d]
 target=dzip_for_nonwindows
}

The version statement also supports an 'else' clause:
version (Windows) {
 [foo/windows.d]
 target=foo_for_windows
} else {
 [foo/notwindows.d]
 target=foo_for_notwindows
}

The version statement in dsss.conf has a fairly strict syntax: the { must be on
the same line as the statement, and the version being tested must be in
parenthesis.


There are quite a few other settings supported:

* exclude
  * Exclude a list of .d files from being included in a library:
    exclude=foo.d bar.d

* buildflags
  * Flags that will be added to the command line for rebuild when building this
    section.

* prebuild, preinstall, preclean, predigen, postbuild, postinstall, postclean,
  postdigen
  * Commands to be run before or after (pre or post) building (build),
    installing (install), cleaning (clean) or generating .di files (digen) for
    the current section. Can be any number of ;-separated commands, and
    supports some special command types:
    * .d files. If a .d file is specified as a command, it will be compiled and
      run.
      * Notably, D files can always use DSSS' headers. That is, the package
        'sss'.

    * install: DSSS has an internal 'install' command, which takes the
      following syntax:
      install <file> <target directory>

    * eval: Run a command (.d file or otherwise), and execute its result
      * For example, the command could print "install chosen/file/to/install
        $INCLUDE_PREFIX"

    * set: Set a setting in DSSS' environment. The syntax is as follows:
      * set <section>.<setting> <value>
      * You may use * to apply a setting to all sections, or simply exclude the
        section (but still include the .) to set a global setting.
      * This is most useful when used via eval, as in:
        eval detectsettings.d

    * add: Like set, but adds to a setting.

  * In any command, you can use environment variables with a '$', such as
    $PREFIX. The following environment variables are provided by DSSS:
    * $DSSS : The dsss binary, if you need to call DSSS recursively. Better
      than counting on it being on the PATH.

    * $PREFIX : The prefix to which the software is being installed.

    * $BIN_PREFIX : The prefix to which binaries are being installed.

    * $LIB_PREFIX : The prefix to which libraries are being installed.

    * $INCLUDE_PREFIX : The prefix to which generated .di interface files are
      being installed.
      * This is the /base/ prefix, so for example the module foo.bar will be
        installed to $INCLUDE_PREFIX/foo/bar.di
      * This directory can also be used for .d files.

    * $DOC_PREFIX : The prefix to which documentation is installed.

    * $ETC_PREFIX : The prefix to which configuration files are being
      installed.


Furthermore, there is a global section for settings which are not specific to
any binary or library. You can add settings to this section simply by adding
them before any section declarations, or by making an empty section declaration
like so:
[]
global_setting=0

The important global settings are 'name' (which will otherwise be gleaned from
the directory name) and 'version' (which will otherwise be set to 'latest').
With these settings, a dsss.conf file would conventionally look something like
this:
name = dzip
version = 1.0
[dzip.d]
target = dzip


There is also a global setting, "requires", which may be used to explicitly
list dependencies:
requires = bintod
In general, it is NOT necessary to use this setting, as DSSS will detect
dependencies based on what is imported from the D source.


It is possible to add a setting to all sections with the special [*] section:
name = dzip
version = 1.0
[*]
buildflags=-g
[main.d]
target = dzipper
[dzip]


You can make 'special' build steps, which do not correspond to D source files
and so do not call the build tool, by naming them prefixed with a +. For
example:
[+genSource]
prebuild = gensource.d


It is possible to have source files spread out through several directories, and
to support this in dsss.conf there is the special type "subdir":
[subtool]
type = subdir

Each subdirectory must have its own dsss.conf . Note that setting type=subdir
will cause DSSS to recurse into that directory, but will not cause that
directory to be visible at compile time. If you want that feature, you will
need to add -I flags to buildflags:
name = dzip
version = 1.0
[*]
buildflags=-g -Isubtool
[subtool]
type = subdir
[main.d]
target = dzipper
[dzip]


At build time, sections will be handled in the order that they appear in the
dsss.conf file, with the exception that binaries are always built last. By
default, every section will be built. This can be overridden with the global
option 'defaulttargets', which allows you to specify a list of targets to build
by default. All targets will be built if 'all' is explicitly specified on the
command line.
